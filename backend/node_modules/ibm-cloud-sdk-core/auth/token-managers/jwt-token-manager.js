"use strict";
/**
 * Copyright 2019 IBM Corp. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var extend = require("extend");
var jwt = require("jsonwebtoken");
var logger_1 = require("../../lib/logger");
var request_wrapper_1 = require("../../lib/request-wrapper");
function getCurrentTime() {
    return Math.floor(Date.now() / 1000);
}
/**
 * A class for shared functionality for parsing, storing, and requesting
 * JWT tokens. Intended to be used as a parent to be extended for token
 * request management. Child classes should implement `requestToken()`
 * to retrieve the bearer token from intended sources.
 */
var JwtTokenManager = /** @class */ (function () {
    /**
     * Create a new [[JwtTokenManager]] instance.
     * @constructor
     * @param {object} options Configuration options.
     * @param {string} options.url for HTTP token requests.
     * @param {boolean} [options.disableSslVerification] A flag that indicates
     *   whether verification of the token server's SSL certificate should be
     *   disabled or not.
     * @param {object<string, string>} [options.headers] Headers to be sent with every
     *   outbound HTTP requests to token services.
     */
    function JwtTokenManager(options) {
        // all parameters are optional
        options = options || {};
        this.tokenInfo = {};
        this.tokenName = 'access_token';
        if (options.url) {
            this.url = options.url;
        }
        // request options
        this.disableSslVerification = Boolean(options.disableSslVerification);
        this.headers = options.headers || {};
        // any config options for the internal request library, like `proxy`, will be passed here
        this.requestWrapperInstance = new request_wrapper_1.RequestWrapper(options);
        // Array of requests pending completion of an active token request -- initially empty
        this.pendingRequests = [];
    }
    /**
     * Retrieve a new token using `requestToken()` in the case there is not a
     *   currently stored token from a previous call, or the previous token
     *   has expired.
     */
    JwtTokenManager.prototype.getToken = function () {
        var _this = this;
        if (!this.tokenInfo[this.tokenName] || this.isTokenExpired()) {
            // 1. request a new token
            return this.pacedRequestToken().then(function () {
                return _this.tokenInfo[_this.tokenName];
            });
        }
        else {
            // If refresh needed, kick one off
            if (this.tokenNeedsRefresh()) {
                this.requestToken().then(function (tokenResponse) {
                    _this.saveTokenInfo(tokenResponse.result);
                });
            }
            // 2. use valid, managed token
            return Promise.resolve(this.tokenInfo[this.tokenName]);
        }
    };
    /**
     * Setter for the disableSslVerification property.
     *
     * @param {boolean} value - the new value for the disableSslVerification
     *   property
     * @returns {void}
     */
    JwtTokenManager.prototype.setDisableSslVerification = function (value) {
        // if they try to pass in a non-boolean value,
        // use the "truthy-ness" of the value
        this.disableSslVerification = Boolean(value);
    };
    /**
     * Set a completely new set of headers.
     *
     * @param {OutgoingHttpHeaders} headers - the new set of headers as an object
     * @returns {void}
     */
    JwtTokenManager.prototype.setHeaders = function (headers) {
        if (typeof headers !== 'object') {
            // do nothing, for now
            return;
        }
        this.headers = headers;
    };
    /**
     * Paces requests to request_token.
     *
     * This method pseudo-serializes requests for an access_token
     * when the current token is undefined or expired.
     * The first caller to this method records its `requestTime` and
     * then issues the token request. Subsequent callers will check the
     * `requestTime` to see if a request is active (has been issued within
     * the past 60 seconds), and if so will queue their promise for the
     * active requestor to resolve when that request completes.
     */
    JwtTokenManager.prototype.pacedRequestToken = function () {
        var _this = this;
        var currentTime = getCurrentTime();
        if (this.requestTime > (currentTime - 60)) {
            // token request is active -- queue the promise for this request
            return new Promise(function (resolve, reject) {
                _this.pendingRequests.push({ resolve: resolve, reject: reject });
            });
        }
        else {
            this.requestTime = currentTime;
            return this.requestToken().then(function (tokenResponse) {
                _this.saveTokenInfo(tokenResponse.result);
                _this.pendingRequests.forEach(function (_a) {
                    var resolve = _a.resolve;
                    resolve();
                });
                _this.pendingRequests = [];
                _this.requestTime = 0;
            }).catch(function (err) {
                _this.pendingRequests.forEach(function (_a) {
                    var reject = _a.reject;
                    reject(err);
                });
                throw (err);
            });
        }
    };
    /**
     * Request a JWT using an API key.
     *
     * @returns {Promise}
     */
    JwtTokenManager.prototype.requestToken = function () {
        var errMsg = '`requestToken` MUST be overridden by a subclass of JwtTokenManagerV1.';
        var err = new Error(errMsg);
        logger_1.default.error(errMsg);
        return Promise.reject(err);
    };
    /**
     * Check if currently stored token is expired
     *
     * @private
     * @returns {boolean}
     */
    JwtTokenManager.prototype.isTokenExpired = function () {
        var expireTime = this.expireTime;
        if (!expireTime) {
            return true;
        }
        var currentTime = getCurrentTime();
        return expireTime <= currentTime;
    };
    /**
     * Check if currently stored token should be refreshed
     * i.e. past the window to request a new token
     *
     * @private
     * @returns {boolean}
     */
    JwtTokenManager.prototype.tokenNeedsRefresh = function () {
        var refreshTime = this.refreshTime;
        var currentTime = getCurrentTime();
        if (refreshTime && refreshTime > currentTime) {
            return false;
        }
        // Update refreshTime to 60 seconds from now to avoid redundant refreshes
        this.refreshTime = currentTime + 60;
        return true;
    };
    /**
     * Save the JWT service response and the calculated expiration time to the object's state.
     *
     * @param tokenResponse - Response object from JWT service request
     * @private
     * @returns {void}
     */
    JwtTokenManager.prototype.saveTokenInfo = function (tokenResponse) {
        var accessToken = tokenResponse[this.tokenName];
        if (!accessToken) {
            var err = 'Access token not present in response';
            logger_1.default.error(err);
            throw new Error(err);
        }
        // the time of expiration is found by decoding the JWT access token
        // exp is the time of expire and iat is the time of token retrieval
        var decodedResponse = jwt.decode(accessToken);
        if (!decodedResponse) {
            var err = 'Access token recieved is not a valid JWT';
            logger_1.default.error(err);
            throw new Error(err);
        }
        var exp = decodedResponse.exp, iat = decodedResponse.iat;
        // There are no required claims in JWT
        if (!exp || !iat) {
            this.expireTime = 0;
            this.refreshTime = 0;
        }
        else {
            var fractionOfTtl = 0.8;
            var timeToLive = exp - iat;
            this.expireTime = exp;
            this.refreshTime = exp - (timeToLive * (1.0 - fractionOfTtl));
        }
        this.tokenInfo = extend({}, tokenResponse);
    };
    return JwtTokenManager;
}());
exports.JwtTokenManager = JwtTokenManager;
